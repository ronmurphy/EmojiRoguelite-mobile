<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">    <title>Emoji Roguelite Adventure</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <style>
        body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
}

#game-container {
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: column;
}

#game-canvas {
    flex-grow: 1;
}
        #hud {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        .menu {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 30;
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
        }
        .menu-btn {
            display: block;
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            font-size: 16px;
            cursor: pointer;
        }
        #virtual-controller {
    position: absolute;
    bottom: 20px;
    left: 20px;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    width: 150px;
    height: 150px;
}

.control-btn {
    width: 50px;
    height: 50px;
    font-size: 24px;
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: rgba(255, 255, 255, 0.3);
    border: none;
    border-radius: 25px;
    cursor: pointer;
    touch-action: manipulation;
}

#up-btn { grid-column: 2; grid-row: 1; }
#left-btn { grid-column: 1; grid-row: 2; }
#right-btn { grid-column: 3; grid-row: 2; }
#down-btn { grid-column: 2; grid-row: 3; }
        #menu-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 24px;
            background: none;
            border: none;
            color: white;
            cursor: pointer;
        }
        .race-btn.selected {
    background-color: #4CAF50;
    color: white;
}
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="hud"></div>
        <div id="virtual-controller">
            <button class="control-btn" id="up-btn">‚¨ÜÔ∏è</button>
            <button class="control-btn" id="left-btn">‚¨ÖÔ∏è</button>
            <button class="control-btn" id="down-btn">‚¨áÔ∏è</button>
            <button class="control-btn" id="right-btn">‚û°Ô∏è</button>
        </div>
        <button id="menu-btn">üìñ</button>
    </div>
    <div id="start-menu" class="menu">
        <h1>Emoji Roguelite Adventure</h1>
        <h2>Choose your race:</h2>
        <div id="race-selection">
            <button class="menu-btn race-btn" data-race="human" data-emoji="üë®">Human üë®</button>
            <button class="menu-btn race-btn" data-race="elf" data-emoji="üßù">Elf üßù</button>
            <button class="menu-btn race-btn" data-race="dwarf" data-emoji="üßî">Dwarf üßî</button>
            <button class="menu-btn race-btn" data-race="halfling" data-emoji="üßí">Halfling üßí</button>
        </div>
        <p id="race-description"></p>
        <button id="ready-btn" class="menu-btn" style="display: none;">Ready</button>
    </div>
    <div id="meta-progression-menu" class="menu">
        <h2>Your Legacy</h2>
        <p>Total Runs: <span id="total-runs"></span></p>
        <p>Highest Level: <span id="highest-level"></span></p>
        <p>Total Coins: <span id="total-coins"></span></p>
        <h3>Permanent Upgrades</h3>
        <button id="upgrade-strength" class="menu-btn">Upgrade Strength (10 coins)</button>
        <button id="upgrade-dexterity" class="menu-btn">Upgrade Dexterity (10 coins)</button>
        <button id="upgrade-luck" class="menu-btn">Upgrade Luck (10 coins)</button>
        <button id="start-new-run" class="menu-btn">Start New Run</button>
    </div>
    <div id="player-menu" class="menu">
        <h2>Player Stats</h2>
        <div id="player-stats"></div>
        <h3>Inventory</h3>
        <div id="inventory"></div>
        <button id="close-menu" class="menu-btn">Close</button>
    </div>
    <script>
        // Game constants
        // const TILE_SIZE = 32;
        const VIEWPORT_WIDTH = 15;
        const VIEWPORT_HEIGHT = 15;
        const VISIBLE_RADIUS = 5;
        const moveDebounceTime = 200; // Milliseconds

        // Game state
        let TILE_SIZE = 32;
        let player;
        let lastTime = 0;
        let lastMoveTime = 0;




        let dungeon = {
    level: 1,
    width: 50,
    height: 50,
    tiles: [],
    rooms: [],
    monsters: [],
    items: []
};
        const BASE_ENEMY_MOVE_INTERVAL = 10000; // 10 seconds in milliseconds
        const tileTypes = {
    FLOOR: 0,
    WALL: 1,
    DOOR: 2,
    STAIRS: 3,
    SHOP: 4,
    TRAP: 5,
    LOCKED_DOOR: 6,
    REVEALED_TRAP: 7
};

        const monsterTypes = [
    { name: 'Rat', emoji: 'üêÄ', hp: 5, strength: 2, xp: 5, minLevel: 1 },
    { name: 'Slime', emoji: 'üü¢', hp: 6, strength: 3, xp: 7, minLevel: 1 },
    { name: 'Fairy', emoji: 'üßöüèæ', hp: 7, strength: 4, xp: 15, minLevel: 2 },
    { name: 'Giant Bug', emoji: 'ü™≤', hp: 8, strength: 4, xp: 8, minLevel: 2 },
    { name: 'Goblin', emoji: 'üë∫', hp: 10, strength: 5, xp: 10, minLevel: 3 },
    { name: 'Skeleton', emoji: 'üíÄ', hp: 12, strength: 6, xp: 12, minLevel: 4 },
    { name: 'Ghost', emoji: 'üëª', hp: 15, strength: 7, xp: 15, minLevel: 5 },
    { name: 'Zombie', emoji: 'üßü', hp: 12, strength: 10, xp: 12, minLevel: 6 },
    { name: 'Werewolf', emoji: 'üê∫', hp: 17, strength: 12, xp: 20, minLevel: 7 },
    { name: 'Vampire', emoji: 'üßõ', hp: 20, strength: 15, xp: 23, minLevel: 8 },
    { name: 'Orc', emoji: 'üëπ', hp: 25, strength: 20, xp: 25, minLevel: 9 },
    { name: 'Troll', emoji: 'üßå', hp: 35, strength: 22, xp: 30, minLevel: 10 },
    { name: 'Dragon', emoji: 'üêâ', hp: 40, strength: 10, xp: 35, minLevel: 12 }
];

        const itemTypes = [
            { name: 'Long Sword', emoji: 'üó°Ô∏è', strength: 10 },
            { name: 'Short Sword', emoji: 'üó°Ô∏è', strength: 8 },
            { name: 'Axe', emoji: 'ü™ì', strength: 9 },
            { name: 'Boomerang', emoji: 'ü™É', strength: 7 },
            { name: 'Bow', emoji: 'üèπ', strength: 4, dexterity: 2 },
            { name: 'Leather Armor', emoji: 'üß•', hp: 5 },
            { name: 'Mace', emoji: 'üèè', strength: 8 },
            { name: 'Dagger', emoji: 'üî™', dexterity: 1, luck: 2 },
            { name: 'Healing Potion', emoji: 'üß™', hp: 5, consumable: true },
            { name: 'Strength Potion', emoji: 'üí™', strength: 2, duration: 5, consumable: true },
            { name: 'Dexterity Potion', emoji: 'üèÉ', dexterity: 2, duration: 5, consumable: true },
            { name: 'Luck Potion', emoji: 'üçÄ', luck: 2, duration: 5, consumable: true },
            { name: 'Coins', emoji: 'üí∞', value: 0 },
            { name: 'Gems', emoji: 'üíé', value: 0 }
        ];

        const skillTypes = [
            { name: 'Fireball', emoji: 'üî•', manaCost: 3, damage: 15 },
            { name: 'Lightning Bolt', emoji: '‚ö°', manaCost: 4, damage: 17 },
            { name: 'Heal', emoji: 'üíö', manaCost: 2, healing: 10 },
            { name: 'Shield', emoji: 'üõ°Ô∏è', manaCost: 2, defense: 5, duration: 3 }
        ];

        // Canvas setup
        let canvas;
let ctx;



function resizeCanvas() {
    if (canvas) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Calculate the number of tiles that should fit on the screen
        const tilesX = VIEWPORT_WIDTH;
        const tilesY = VIEWPORT_HEIGHT;
        
        // Calculate TILE_SIZE based on the smaller dimension
        TILE_SIZE = Math.floor(Math.min(
            canvas.width / tilesX,
            canvas.height / tilesY
        ));
        
        if (dungeon && dungeon.tiles && player) {
            drawGame();
        }
    }
}
// Add event listener for window resize
window.addEventListener('resize', resizeCanvas);

window.addEventListener('orientationchange', resizeCanvas);

// Call resizeCanvas initially
resizeCanvas();



function gameLoop(currentTime) {
    update(currentTime);
    drawGame();
    requestAnimationFrame(gameLoop);
}

         function update(currentTime) {
    if (!lastTime) lastTime = currentTime;
    const deltaTime = currentTime - lastTime;
    
    const moveInterval = Math.max(1000, BASE_ENEMY_MOVE_INTERVAL - (dungeon.level - 1) * 1000);
    
    if (deltaTime >= moveInterval) {
        moveEnemies();
        lastTime = currentTime;
    }
}

function moveEnemies() {
    dungeon.monsters.forEach(monster => {
        if (Math.abs(monster.x - player.x) <= 1 && Math.abs(monster.y - player.y) <= 1) {
            // Monster is adjacent to player, move towards player
            const dx = Math.sign(player.x - monster.x);
            const dy = Math.sign(player.y - monster.y);
            if (isValidMove(monster.x + dx, monster.y + dy)) {
                monster.x += dx;
                monster.y += dy;
            }
        } else {
            // Monster is not adjacent to player, move randomly
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            const validDirections = directions.filter(([dx, dy]) =>
                isValidMove(monster.x + dx, monster.y + dy)
            );
            if (validDirections.length > 0) {
                const [dx, dy] = validDirections[Math.floor(Math.random() * validDirections.length)];
                monster.x += dx;
                monster.y += dy;
            }
        }
    });
}

function isValidMove(x, y) {
    return x >= 0 && x < dungeon.width && y >= 0 && y < dungeon.height && 
           dungeon.tiles[y][x] !== tileTypes.WALL;
}

function drawGame() {
    if (!ctx || !dungeon || !dungeon.tiles || !player) {
        console.log("Game state not fully initialized yet");
        return;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Calculate the number of tiles that can fit on the screen
    const tilesX = Math.floor(canvas.width / TILE_SIZE);
    const tilesY = Math.floor(canvas.height / TILE_SIZE);
    
    // Calculate the start and end of the viewport, centered on the player
    const startX = Math.max(0, Math.floor(player.x - tilesX / 2));
    const startY = Math.max(0, Math.floor(player.y - tilesY / 2));
    const endX = Math.min(dungeon.width, startX + tilesX);
    const endY = Math.min(dungeon.height, startY + tilesY);

    // Calculate offset to center the view and account for partial tiles
    const offsetX = Math.floor((canvas.width - (endX - startX) * TILE_SIZE) / 2);
    const offsetY = Math.floor((canvas.height - (endY - startY) * TILE_SIZE) / 2);

    // Draw tiles
    for (let y = startY; y < endY; y++) {
        if (dungeon.tiles[y]) {
            for (let x = startX; x < endX; x++) {
                if (dungeon.tiles[y][x] !== undefined) {
                    const screenX = (x - startX) * TILE_SIZE + offsetX;
                    const screenY = (y - startY) * TILE_SIZE + offsetY;
                    drawTile(dungeon.tiles[y][x], screenX, screenY);
                }
            }
        }
    }

    // Draw items
    dungeon.items.forEach(item => {
        if (item.x >= startX && item.x < endX && item.y >= startY && item.y < endY) {
            const screenX = (item.x - startX) * TILE_SIZE + offsetX;
            const screenY = (item.y - startY) * TILE_SIZE + offsetY;
            drawEntity(item, screenX, screenY);
        }
    });

    // Draw monsters
    dungeon.monsters.forEach(monster => {
        if (monster.x >= startX && monster.x < endX && monster.y >= startY && monster.y < endY) {
            const screenX = (monster.x - startX) * TILE_SIZE + offsetX;
            const screenY = (monster.y - startY) * TILE_SIZE + offsetY;
            drawEntity(monster, screenX, screenY);
        }
    });

    // Draw player
    const playerScreenX = (player.x - startX) * TILE_SIZE + offsetX;
    const playerScreenY = (player.y - startY) * TILE_SIZE + offsetY;
    drawEntity(player, playerScreenX, playerScreenY);
}

function drawTile(tileType, x, y) {
    switch (tileType) {
        case tileTypes.FLOOR:
            ctx.fillStyle = '#CCC';
            break;
        case tileTypes.WALL:
            ctx.fillStyle = '#666';
            break;
        case tileTypes.DOOR:
            ctx.fillStyle = '#8B4513';
            break;
        case tileTypes.STAIRS:
            ctx.fillStyle = '#FFD700';
            break;
        case tileTypes.SHOP:
            ctx.fillStyle = '#4169E1';
            break;
        case tileTypes.TRAP:
            ctx.fillStyle = '#CCC'; // Same as floor, it's hidden
            break;
        case tileTypes.LOCKED_DOOR:
            ctx.fillStyle = '#A52A2A';
            break;
        case tileTypes.REVEALED_TRAP:
            ctx.fillStyle = '#FF69B4';
            break;
        default:
            ctx.fillStyle = '#FF00FF'; // Magenta for unknown tile types
    }
    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
}

function drawEntity(entity, x, y) {
    ctx.font = `${TILE_SIZE}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(entity.emoji, x + TILE_SIZE / 2, y + TILE_SIZE / 2);
}

        // Input handling
        function movePlayer(dx, dy) {
    const currentTime = Date.now();
    if (currentTime - lastMoveTime < moveDebounceTime) {
        return; // Ignore this move if it's too soon after the last one
    }
    lastMoveTime = currentTime;

    const newX = player.x + dx;
    const newY = player.y + dy;
    if (newX >= 0 && newX < dungeon.width && newY >= 0 && newY < dungeon.height) {
        const tileType = dungeon.tiles[newY][newX];
        if (tileType === tileTypes.FLOOR || tileType === tileTypes.TRAP || tileType === tileTypes.REVEALED_TRAP) {
            player.x = newX;
            player.y = newY;
            if (tileType === tileTypes.TRAP) {
                handleTrap(newX, newY);
            }
            checkForEncounters();
            drawGame();  // Redraw the game after moving
        } else if (tileType === tileTypes.LOCKED_DOOR) {
            const door = dungeon.lockedDoors.find(door => door.x === newX && door.y === newY);
            if (door && player.inventory.some(item => item.name === 'Key' && item.doorId === door.id)) {
                unlockDoor(door);
                player.x = newX;
                player.y = newY;
                drawGame();  // Redraw the game after moving
            } else {
                alert("This door is locked. You need a key to open it.");
            }
        }
    }
}

function initVirtualController() {
    const buttons = [
        { id: 'up-btn', dx: 0, dy: -1 },
        { id: 'down-btn', dx: 0, dy: 1 },
        { id: 'left-btn', dx: -1, dy: 0 },
        { id: 'right-btn', dx: 1, dy: 0 }
    ];

    buttons.forEach(button => {
        const elem = document.getElementById(button.id);
        if (elem) {
            let touchStarted = false;

            elem.addEventListener('touchstart', function(e) {
                e.preventDefault();
                if (!touchStarted) {
                    touchStarted = true;
                    movePlayer(button.dx, button.dy);
                }
            });

            elem.addEventListener('touchend', function(e) {
                e.preventDefault();
                touchStarted = false;
            });

            // Keep click event listeners for non-touch devices
            elem.addEventListener('mousedown', function(e) {
                e.preventDefault();
                movePlayer(button.dx, button.dy);
            });
        }
    });
}


function handleTrap(x, y) {
    const trapChance = Math.random();
    if (trapChance > player.stats.luck / 100) {
        const damage = Math.floor(Math.random() * 5) + 1;
        player.stats.hp -= damage;
        alert(`You triggered a trap! You take ${damage} damage.`);
        if (player.stats.hp <= 0) {
            gameOver();
        }
    } else {
        alert("Your luck allowed you to avoid the trap!");
    }
    dungeon.tiles[y][x] = tileTypes.REVEALED_TRAP;
}

function unlockDoor(door) {
    dungeon.tiles[door.y][door.x] = tileTypes.FLOOR;
    player.inventory = player.inventory.filter(item => !(item.name === 'Key' && item.doorId === door.id));
    alert("You unlocked the door!");
}

 // end part 1
 function togglePlayerMenu() {
            const playerMenu = document.getElementById('player-menu');
            playerMenu.style.display = playerMenu.style.display === 'none' ? 'block' : 'none';
            if (playerMenu.style.display === 'block') updatePlayerMenu();
        }

        function initializeGameState() {
    dungeon = {
        level: 1,
        width: 50,
        height: 50,
        tiles: [],
        rooms: [],
        monsters: [],
        items: []
    };
    
    if (!player) {
        player = {};
    }
    
    // Update player properties
    player.x = 0;
    player.y = 0;
    player.race = '';
    player.emoji = 'üë§'; // Default emoji if no race is selected
    player.stats = {
        strength: 5,
        dexterity: 5,
        mana: 5,
        luck: 5,
        hp: 10,
        maxHp: 10,
        xp: 0,
        level: 1
    };
    player.inventory = [];
    player.equippedItems = {
        weapon: null,
        armor: null
    };
    player.coins = 0;
    player.skills = [];
}

function generateDungeon() {
    // Cap the dungeon level at 15
    dungeon.level = Math.min(dungeon.level, 15);

    // Scale dungeon size with level
    dungeon.width = 50 + (dungeon.level * 2);
    dungeon.height = 50 + (dungeon.level * 2);

    dungeon.tiles = [];
    dungeon.rooms = [];
    dungeon.monsters = [];
    dungeon.items = [];
    dungeon.traps = [];
    dungeon.lockedDoors = [];
    dungeon.keys = [];

    // Initialize tiles with walls
    for (let y = 0; y < dungeon.height; y++) {
        dungeon.tiles[y] = [];
        for (let x = 0; x < dungeon.width; x++) {
            dungeon.tiles[y][x] = tileTypes.WALL;
        }
    }

    // Generate rooms
    const numRooms = 5 + Math.floor(dungeon.level * 1.5);
    for (let i = 0; i < numRooms; i++) {
        const room = generateRoom();
        if (placeRoom(room)) {
            dungeon.rooms.push(room);
        }
    }

    // Connect rooms
    for (let i = 1; i < dungeon.rooms.length; i++) {
        connectRooms(dungeon.rooms[i-1], dungeon.rooms[i]);
    }

    // Place stairs in a random room (not the first one)
    const stairsRoom = dungeon.rooms[1 + Math.floor(Math.random() * (dungeon.rooms.length - 1))];
    const stairsX = stairsRoom.x + Math.floor(Math.random() * stairsRoom.width);
    const stairsY = stairsRoom.y + Math.floor(Math.random() * stairsRoom.height);
    dungeon.tiles[stairsY][stairsX] = tileTypes.STAIRS;

    // Place shop in a random room
    const shopRoom = dungeon.rooms[Math.floor(Math.random() * dungeon.rooms.length)];
    const shopX = shopRoom.x + Math.floor(Math.random() * shopRoom.width);
    const shopY = shopRoom.y + Math.floor(Math.random() * shopRoom.height);
    dungeon.tiles[shopY][shopX] = tileTypes.SHOP;

    // Place traps
    const numTraps = Math.floor(dungeon.level * 1.5);
    for (let i = 0; i < numTraps; i++) {
        placeTrap();
    }

    // Place locked doors and keys
    const numLockedDoors = Math.floor(dungeon.level / 3);
    for (let i = 0; i < numLockedDoors; i++) {
        placeLockedDoorAndKey();
    }

    // Generate monsters and items
    generateMonstersAndItems();

    placePlayerInValidPosition();
}

function placeTrap() {
    let x, y;
    do {
        const room = dungeon.rooms[Math.floor(Math.random() * dungeon.rooms.length)];
        x = room.x + Math.floor(Math.random() * room.width);
        y = room.y + Math.floor(Math.random() * room.height);
    } while (dungeon.tiles[y][x] !== tileTypes.FLOOR);
    
    dungeon.tiles[y][x] = tileTypes.TRAP;
    dungeon.traps.push({x, y});
}

function placeLockedDoorAndKey() {
    // Place locked door
    let doorX, doorY;
    do {
        const room = dungeon.rooms[Math.floor(Math.random() * dungeon.rooms.length)];
        doorX = room.x + Math.floor(Math.random() * room.width);
        doorY = room.y + Math.floor(Math.random() * room.height);
    } while (dungeon.tiles[doorY][doorX] !== tileTypes.FLOOR);
    
    dungeon.tiles[doorY][doorX] = tileTypes.LOCKED_DOOR;
    const doorId = dungeon.lockedDoors.length;
    dungeon.lockedDoors.push({x: doorX, y: doorY, id: doorId});

    // Place key in a different room
    let keyX, keyY, keyRoom;
    do {
        keyRoom = dungeon.rooms[Math.floor(Math.random() * dungeon.rooms.length)];
        keyX = keyRoom.x + Math.floor(Math.random() * keyRoom.width);
        keyY = keyRoom.y + Math.floor(Math.random() * keyRoom.height);
    } while (dungeon.tiles[keyY][keyX] !== tileTypes.FLOOR || (keyRoom === dungeon.rooms.find(room => doorX >= room.x && doorX < room.x + room.width && doorY >= room.y && doorY < room.y + room.height)));
    
    dungeon.keys.push({x: keyX, y: keyY, id: doorId});
    dungeon.items.push({x: keyX, y: keyY, name: 'Key', emoji: 'üîë', doorId: doorId});
}

function placePlayerInValidPosition() {
    // Find a floor tile to place the player
    for (let y = 0; y < dungeon.height; y++) {
        for (let x = 0; x < dungeon.width; x++) {
            if (dungeon.tiles[y][x] === tileTypes.FLOOR) {
                player.x = x;
                player.y = y;
                return;
            }
        }
    }
    // If no floor tile found, place player at (0,0) as a fallback
    player.x = 0;
    player.y = 0;
}

function generateRoom() {
    const minSize = 3;
    const maxSize = 8;
    return {
        x: 0,
        y: 0,
        width: minSize + Math.floor(Math.random() * (maxSize - minSize + 1)),
        height: minSize + Math.floor(Math.random() * (maxSize - minSize + 1))
    };
}

function placeRoom(room) {
    const padding = 1;
    let attempts = 50;
    while (attempts > 0) {
        room.x = padding + Math.floor(Math.random() * (dungeon.width - room.width - padding * 2));
        room.y = padding + Math.floor(Math.random() * (dungeon.height - room.height - padding * 2));

        if (isRoomValid(room)) {
            for (let y = room.y; y < room.y + room.height; y++) {
                for (let x = room.x; x < room.x + room.width; x++) {
                    dungeon.tiles[y][x] = tileTypes.FLOOR;
                }
            }
            return true;
        }
        attempts--;
    }
    return false;
}

function isRoomValid(room) {
    const padding = 1;
    for (let y = room.y - padding; y < room.y + room.height + padding; y++) {
        for (let x = room.x - padding; x < room.x + room.width + padding; x++) {
            if (y < 0 || y >= dungeon.height || x < 0 || x >= dungeon.width || dungeon.tiles[y][x] === tileTypes.FLOOR) {
                return false;
            }
        }
    }
    return true;
}

function connectRooms(roomA, roomB) {
    let x = roomA.x + Math.floor(roomA.width / 2);
    let y = roomA.y + Math.floor(roomA.height / 2);
    const targetX = roomB.x + Math.floor(roomB.width / 2);
    const targetY = roomB.y + Math.floor(roomB.height / 2);

    while (x !== targetX || y !== targetY) {
        if (x !== targetX) {
            x += x < targetX ? 1 : -1;
        } else if (y !== targetY) {
            y += y < targetY ? 1 : -1;
        }
        dungeon.tiles[y][x] = tileTypes.FLOOR;
    }
}

function generateMonstersAndItems() {
    const numMonsters = dungeon.level + 2;
    const numItems = 3 + Math.floor(Math.random() * 3);

    // Filter monsters based on dungeon level
    const availableMonsters = monsterTypes.filter(monster => monster.minLevel <= dungeon.level);

    for (let i = 0; i < numMonsters; i++) {
        const room = dungeon.rooms[Math.floor(Math.random() * dungeon.rooms.length)];
        
        // Weighted random selection favoring stronger monsters in higher levels
        let totalWeight = 0;
        const weights = availableMonsters.map(monster => {
            const weight = monster.xp * (dungeon.level - monster.minLevel + 1);
            totalWeight += weight;
            return weight;
        });

        let randomWeight = Math.random() * totalWeight;
        let selectedMonsterIndex = 0;
        for (let j = 0; j < weights.length; j++) {
            randomWeight -= weights[j];
            if (randomWeight <= 0) {
                selectedMonsterIndex = j;
                break;
            }
        }

        const monsterTemplate = availableMonsters[selectedMonsterIndex];
        const monster = {
            x: room.x + Math.floor(Math.random() * room.width),
            y: room.y + Math.floor(Math.random() * room.height),
            ...JSON.parse(JSON.stringify(monsterTemplate))
        };

        // Scale monster stats based on dungeon level
        const levelDifference = dungeon.level - monster.minLevel;
        monster.hp += Math.floor(levelDifference * 1.5);
        monster.strength += Math.floor(levelDifference * 0.5);
        monster.xp += Math.floor(levelDifference * 2);

        dungeon.monsters.push(monster);
    }

    // Item generation remains the same
    for (let i = 0; i < numItems; i++) {
        const room = dungeon.rooms[Math.floor(Math.random() * dungeon.rooms.length)];
        const item = {
            x: room.x + Math.floor(Math.random() * room.width),
            y: room.y + Math.floor(Math.random() * room.height),
            ...JSON.parse(JSON.stringify(itemTypes[Math.floor(Math.random() * itemTypes.length)]))
        };
        if (item.name === 'Coins') {
            item.value = dungeon.level + Math.floor(Math.random() * 10);
        }
        if (item.name === 'Gems') {
            item.value = dungeon.level + Math.floor(Math.random() * 25);
        }
        dungeon.items.push(item);
    }
}

        function checkForEncounters() {
            // Check for stairs
            if (dungeon.tiles[player.y][player.x] === tileTypes.STAIRS) {
                dungeon.level++;
                generateDungeon();
                updateHUD();
                alert(`You've reached level ${dungeon.level}!`);
            }

            // Check for shop
            if (dungeon.tiles[player.y][player.x] === tileTypes.SHOP) {
                openShop();
            }




            // Check for monsters
            const monsterIndex = dungeon.monsters.findIndex(m => m.x === player.x && m.y === player.y);
            if (monsterIndex !== -1) {
                startCombat(dungeon.monsters[monsterIndex]);
            }

            // Check for items
            const itemIndex = dungeon.items.findIndex(i => i.x === player.x && i.y === player.y);
    if (itemIndex !== -1) {
        const item = dungeon.items[itemIndex];
        if (item.name === 'Key') {
            player.inventory.push(item);
            alert(`You found a key!`);
        } else if (item.name === 'Coins') {
            player.coins += item.value;
        } else {
            player.inventory.push(item);
        }
        dungeon.items.splice(itemIndex, 1);
        updatePlayerMenu();
        if (item.name !== 'Key') {
            alert(`You found ${item.name}!`);
        }
    }
        }

        function openShop() {
            const shopItems = [
                { name: 'Healing Potion', price: 10 },
                { name: 'Strength Potion', price: 15 },
                { name: 'Dexterity Potion', price: 15 },
                { name: 'Luck Potion', price: 15 }
            ];

            let shopMenu = 'Welcome to the shop! What would you like to buy?\n\n';
            shopItems.forEach((item, index) => {
                shopMenu += `${index + 1}. ${item.name} - ${item.price} coins\n`;
            });
            shopMenu += '\nEnter the number of the item you want to buy, or 0 to exit:';

            const choice = parseInt(prompt(shopMenu));
            if (choice > 0 && choice <= shopItems.length) {
                const selectedItem = shopItems[choice - 1];
                if (player.coins >= selectedItem.price) {
                    player.coins -= selectedItem.price;
                    const boughtItem = itemTypes.find(i => i.name === selectedItem.name);
                    player.inventory.push(JSON.parse(JSON.stringify(boughtItem)));
                    alert(`You bought a ${selectedItem.name}!`);
                    updatePlayerMenu();
                    updateHUD();
                } else {
                    alert("You don't have enough coins!");
                }
            }
        }

        function startCombat(monster) {
            alert(`You encounter a ${monster.name}!`);
            while (player.stats.hp > 0 && monster.hp > 0) {
                // Player's turn
                const damage = Math.max(1, player.stats.strength - (monster.strength / 2));
                monster.hp -= damage;
                alert(`You deal ${damage} damage to the ${monster.name}!`);

                if (monster.hp <= 0) {
                    alert(`You defeated the ${monster.name}!`);
                    player.stats.xp += monster.xp;
                    checkLevelUp();
                    dungeon.monsters = dungeon.monsters.filter(m => m !== monster);
                    return;
                }

                // Monster's turn
                const monsterDamage = Math.max(1, monster.strength - (player.stats.dexterity / 2));
                player.stats.hp -= monsterDamage;
                alert(`The ${monster.name} deals ${monsterDamage} damage to you!`);

                if (player.stats.hp <= 0) {
                    gameOver();
                    return;
                }
            }
        }

        function checkLevelUp() {
            const xpThreshold = player.stats.level * 100;
            if (player.stats.xp >= xpThreshold) {
                player.stats.level++;
                player.stats.xp -= xpThreshold;
                player.stats.strength++;
                player.stats.dexterity++;
                player.stats.mana++;
                player.stats.luck++;
                player.stats.maxHp += 5;
                player.stats.hp = player.stats.maxHp;
                alert(`Level up! You are now level ${player.stats.level}!`);
                updatePlayerMenu();
            }
        }

        function gameOver() {
            alert('Game Over! Your adventure has come to an end.');
            saveProgress();
            showMetaProgressionMenu();
        }

        function saveProgress() {
            let persistentProgress = {
                totalRuns: (parseInt(localStorage.getItem('totalRuns')) || 0) + 1,
                highestLevel: Math.max(dungeon.level, parseInt(localStorage.getItem('highestLevel')) || 0),
                totalCoins: (parseInt(localStorage.getItem('totalCoins')) || 0) + player.coins
            };
            
            for (let key in persistentProgress) {
                localStorage.setItem(key, persistentProgress[key]);
            }
        }

        function showMetaProgressionMenu() {
            document.getElementById('game-container').style.display = 'none';
            document.getElementById('meta-progression-menu').style.display = 'block';
            
            document.getElementById('total-runs').textContent = localStorage.getItem('totalRuns') || 0;
            document.getElementById('highest-level').textContent = localStorage.getItem('highestLevel') || 1;
            document.getElementById('total-coins').textContent = localStorage.getItem('totalCoins') || 0;
        }

        function buyUpgrade(stat) {
            let totalCoins = parseInt(localStorage.getItem('totalCoins')) || 0;
            if (totalCoins >= 10) {
                totalCoins -= 10;
                localStorage.setItem('totalCoins', totalCoins);
                let upgrades = JSON.parse(localStorage.getItem('permanentUpgrades')) || {};
                upgrades[stat] = (upgrades[stat] || 0) + 1;
                localStorage.setItem('permanentUpgrades', JSON.stringify(upgrades));
                showMetaProgressionMenu();
            } else {
                alert("Not enough coins!");
            }
        }

        function handleKeyDown(e) {
    switch (e.key) {
        case 'ArrowUp':
            movePlayer(0, -1);
            break;
        case 'ArrowDown':
            movePlayer(0, 1);
            break;
        case 'ArrowLeft':
            movePlayer(-1, 0);
            break;
        case 'ArrowRight':
            movePlayer(1, 0);
            break;
        case 'i':
            togglePlayerMenu();
            break;
    }
}

// Add this event listener to the document
document.addEventListener('keydown', handleKeyDown);

        
        function startNewRun() {
    console.log("Starting new run...");
    document.getElementById('meta-progression-menu').style.display = 'none';
    document.getElementById('start-menu').style.display = 'block';
    document.getElementById('game-container').style.display = 'none';
    
    // Reset player object entirely
    initializeGameState();
    
    // Reset race selection UI
    document.querySelectorAll('.race-btn').forEach(btn => btn.classList.remove('selected'));
    document.getElementById('race-description').textContent = '';
    document.getElementById('ready-btn').style.display = 'none';
}

        function applyPermanentUpgrades() {
            let upgrades = JSON.parse(localStorage.getItem('permanentUpgrades')) || {};
            for (let stat in upgrades) {
                player.stats[stat] += upgrades[stat];
            }
        }

        function updateHUD() {
            const hudEl = document.getElementById('hud');
            hudEl.innerHTML = `
                LVL:${player.stats.level} | HP:${player.stats.hp}/${player.stats.maxHp} | XP:${player.stats.xp} 
                | üí∞:${player.coins} | ü™ú:${dungeon.level}
            `;
        }

        function updatePlayerMenu() {
            const statsEl = document.getElementById('player-stats');
            statsEl.innerHTML = '';
            for (const [stat, value] of Object.entries(player.stats)) {
                statsEl.innerHTML += `<div>${stat}: ${value}</div>`;
            }

            const inventoryEl = document.getElementById('inventory');
            inventoryEl.innerHTML = '';
            for (const item of player.inventory) {
                const itemEl = document.createElement('div');
                itemEl.className = 'inventory-item';
                itemEl.innerHTML = `
                    <span>${item.emoji} ${item.name}</span>
                    <button class="equip-btn" data-item="${item.name}">Use/Equip</button>
                `;
                inventoryEl.appendChild(itemEl);
            }

            document.querySelectorAll('.equip-btn').forEach(btn => {
                btn.onclick = () => useItem(btn.dataset.item);
            });

            updateHUD();
        }

        function useItem(itemName) {
            const item = player.inventory.find(i => i.name === itemName);
            if (!item) return;

            if (item.consumable) {
                for (const stat in item) {
                    if (typeof item[stat] === 'number' && stat !== 'x' && stat !== 'y') {
                        player.stats[stat] += item[stat];
                    }
                }
                player.inventory = player.inventory.filter(i => i !== item);
                alert(`You used the ${item.name}!`);
                //part 2
            } else {
                if (item.strength || item.dexterity) {
                    if (player.equippedItems.weapon) {
                        // Unequip current weapon
                        for (const stat in player.equippedItems.weapon) {
                            if (typeof player.equippedItems.weapon[stat] === 'number') {
                                player.stats[stat] -= player.equippedItems.weapon[stat];
                            }
                        }
                    }
                    player.equippedItems.weapon = item;
                } else if (item.hp) {
                    if (player.equippedItems.armor) {
                        // Unequip current armor
                        player.stats.maxHp -= player.equippedItems.armor.hp;
                        player.stats.hp = Math.min(player.stats.hp, player.stats.maxHp);
                    }
                    player.equippedItems.armor = item;
                    player.stats.maxHp += item.hp;
                    player.stats.hp += item.hp;
                }

                // Apply item stats
                for (const stat in item) {
                    if (typeof item[stat] === 'number' && stat !== 'x' && stat !== 'y') {
                        player.stats[stat] += item[stat];
                    }
                }

                alert(`You equipped the ${item.name}!`);
            }

            updatePlayerMenu();
        }

        // Race selection
        const raceButtons = document.querySelectorAll('.race-btn');
        const raceDescription = document.getElementById('race-description');
        const readyButton = document.getElementById('ready-btn');

        raceButtons.forEach(button => {
    button.addEventListener('click', () => {
        // Remove 'selected' class from all buttons
        raceButtons.forEach(btn => btn.classList.remove('selected'));
        // Add 'selected' class to clicked button
        button.classList.add('selected');
        
        player.race = button.dataset.race;
        player.emoji = button.dataset.emoji; // Directly set the emoji here
        console.log(`Race selected: ${player.race}, Emoji: ${player.emoji}`); // Debug log
        updateRaceDescription();
        readyButton.style.display = 'block';
    });
});

        function updateRaceDescription() {
            const descriptions = {
                human: "+1 to all stats",
                elf: "+3 to dexterity, +1 to mana",
                dwarf: "+3 to strength, +1 to luck",
                halfling: "+2 to dexterity, +2 to luck"
            };
            raceDescription.textContent = descriptions[player.race];
        }

        readyButton.addEventListener('click', () => {
    if (!player.race) {
        alert("Please select a race before starting the game.");
        return;
    }

    document.getElementById('start-menu').style.display = 'none';
    document.getElementById('game-container').style.display = 'block';
    
    // Apply upgrades and bonuses
    applyPermanentUpgrades();
    applyRacialBonuses();
    
    // Generate dungeon and update HUD
    generateDungeon();
    updateHUD();
    
    console.log(`Game starting with race: ${player.race}, emoji: ${player.emoji}`); // Debug log
    
    // Start the game loop
    gameLoop();
    
    // Make sure the canvas is properly sized
    resizeCanvas();
});

function applyRacialBonuses() {
    if (!player.race) {
        console.warn("Player race not set. Skipping racial bonuses.");
        return;
    }
    console.log(`Applying racial bonuses for ${player.race}, Current emoji: ${player.emoji}`); // Debug log
    switch (player.race) {
        case 'human':
            for (const stat in player.stats) {
                player.stats[stat]++;
            }
            player.emoji = 'üë®';
            break;
        case 'elf':
            player.stats.dexterity += 3;
            player.stats.mana++;
            player.emoji = 'üßù';
            break;
        case 'dwarf':
            player.stats.strength += 3;
            player.stats.luck++;
            player.emoji = 'üßî';
            break;
        case 'halfling':
            player.stats.dexterity += 2;
            player.stats.luck += 2;
            player.emoji = 'üßí';
            break;
    }
    
    // Recalculate max HP based on race
    player.stats.maxHp = player.stats.hp = (player.race === 'elf' || player.race === 'halfling') ?
        player.stats.dexterity + player.stats.luck :
        player.stats.strength + player.stats.luck;
        console.log(`After applying bonuses, emoji: ${player.emoji}`); // Debug log
}

        // Event listeners for meta-progression menu
        document.getElementById('upgrade-strength').addEventListener('click', () => buyUpgrade('strength'));
        document.getElementById('upgrade-dexterity').addEventListener('click', () => buyUpgrade('dexterity'));
        document.getElementById('upgrade-luck').addEventListener('click', () => buyUpgrade('luck'));
        document.getElementById('start-new-run').addEventListener('click', startNewRun);

        // Menu button
        document.getElementById('menu-btn').addEventListener('click', togglePlayerMenu);

        // Close menu button
        document.getElementById('close-menu').addEventListener('click', togglePlayerMenu);

        // Initialize the game
        function initGame() {
    console.log("Initializing game...");
    canvas = document.getElementById('game-canvas');
    if (canvas) {
        ctx = canvas.getContext('2d');
        
        // Initialize game state
        initializeGameState();
        
        // Now it's safe to resize
        resizeCanvas();
        
        // Add event listeners
        window.addEventListener('resize', resizeCanvas);
        document.addEventListener('keydown', handleKeyDown);
        
        // Initialize virtual controller
        initVirtualController();

                // Check if the device supports touch, show/hide virtual controller accordingly
                if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            document.getElementById('virtual-controller').style.display = 'grid';
        } else {
            document.getElementById('virtual-controller').style.display = 'none';
        }
        
        // Show the meta-progression menu
        showMetaProgressionMenu();
    } else {
        console.error("Canvas element not found!");
    }
}

        // Start the game
        initGame();

        window.onload = initGame;
    </script>
</body>
</html>
