<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Emoji Roguelite Adventure</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: "Noto Sans", sans-serif;
            overflow: hidden;
            touch-action: manipulation;
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #game-canvas {
            flex-grow: 1;
        }
        #hud {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        .menu {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 30;
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
        }
        .menu-btn {
            display: block;
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            font-size: 16px;
            cursor: pointer;
        }
        #virtual-controller {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            width: 150px;
            height: 150px;
        }
        .control-btn {
            width: 50px;
            height: 50px;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.3);
            border: none;
            border-radius: 25px;
            cursor: pointer;
            touch-action: manipulation;
        }
        #up-btn { grid-column: 2; grid-row: 1; }
        #left-btn { grid-column: 1; grid-row: 2; }
        #right-btn { grid-column: 3; grid-row: 2; }
        #down-btn { grid-column: 2; grid-row: 3; }
        #menu-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 24px;
            background: none;
            border: none;
            color: white;
            cursor: pointer;
        }
        .race-btn.selected {
            background-color: #4CAF50;
            color: white;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
        }
        .modal-content {
            background-color: #f4f4f4;
            margin: 10% auto;
            padding: 20px;
            border-radius: 10px;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .shop-sections {
            display: flex;
            justify-content: space-between;
        }
        .shop-section {
            width: 48%;
        }
        .shop-item, .inventory-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .item-emoji {
            font-size: 24px;
            margin-right: 10px;
        }
        .item-details {
            flex-grow: 1;
        }
        .item-name {
            font-weight: bold;
        }
        .item-price {
            color: #888;
        }
        .buy-btn, .sell-btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 5px 10px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 3px;
        }
        #close-shop {
            display: block;
            margin: 20px auto 0;
            padding: 10px 20px;
            font-size: 16px;
        }
        #player-coins {
            text-align: center;
            font-size: 18px;
            margin-top: 20px;
        }
        #notification-area {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
        }
        #combat-log {
            display: none;
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 400px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
        #card-combat-ui {
            display: none;
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 10px;
            z-index: 1001;
        }
        #card-hand {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
        }
        #card-hand button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="hud"></div>
        <div id="virtual-controller">
            <button class="control-btn" id="up-btn">‚¨ÜÔ∏è</button>
            <button class="control-btn" id="left-btn">‚¨ÖÔ∏è</button>
            <button class="control-btn" id="down-btn">‚¨áÔ∏è</button>
            <button class="control-btn" id="right-btn">‚û°Ô∏è</button>
        </div>
        <button id="menu-btn">üìñ</button>
    </div>
    <div id="start-menu" class="menu">
        <h1>Emoji Roguelite Adventure</h1>
        <h2>Choose your race:</h2>
        <div id="race-selection">
            <button class="menu-btn race-btn" data-race="human" data-emoji="üë®">Human üë®</button>
            <button class="menu-btn race-btn" data-race="elf" data-emoji="üßù">Elf üßù</button>
            <button class="menu-btn race-btn" data-race="dwarf" data-emoji="üßî">Dwarf üßî</button>
            <button class="menu-btn race-btn" data-race="halfling" data-emoji="üßí">Halfling üßí</button>
        </div>
        <p id="race-description"></p>
        <button id="ready-btn" class="menu-btn" style="display: none;">Ready</button>
    </div>
    <div id="meta-progression-menu" class="menu">
        <h2>Your Legacy</h2>
        <p>Total Runs: <span id="total-runs"></span></p>
        <p>Highest Level: <span id="highest-level"></span></p>
        <p>Total Coins: <span id="total-coins"></span></p>
        <h3>Permanent Upgrades</h3>
        <button id="upgrade-strength" class="menu-btn">Upgrade Strength (10 coins)</button>
        <button id="upgrade-dexterity" class="menu-btn">Upgrade Dexterity (10 coins)</button>
        <button id="upgrade-luck" class="menu-btn">Upgrade Luck (10 coins)</button>
        <button id="start-new-run" class="menu-btn">Start New Run</button>
    </div>
    <div id="player-menu" class="menu">
        <h2>Player Stats</h2>
        <div id="player-stats"></div>
        <h3>Inventory</h3>
        <div id="inventory"></div>
        <button id="close-menu" class="menu-btn">Close</button>
    </div>
    <div id="shop-modal" class="modal">
        <div class="modal-content">
            <h2>Shop</h2>
            <div class="shop-sections">
                <div class="shop-section">
                    <h3>Buy Items</h3>
                    <div id="shop-items"></div>
                </div>
                <div class="shop-section">
                    <h3>Sell Items</h3>
                    <div id="player-inventory"></div>
                </div>
            </div>
            <div id="player-coins"></div>
            <button id="close-shop">Close Shop</button>
        </div>
    </div>
    <div id="notification-area"></div>
    <div id="combat-log"></div>
    <div id="card-combat-ui">
        <div id="monster-info"></div>
        <div id="player-info"></div>
        <div id="card-hand"></div>
    </div>
    <div id="sell-confirmation" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 20px; border-radius: 10px; z-index: 1001;">
        <p id="sell-message"></p>
        <button id="sell-yes">Yes</button>
        <button id="sell-no">No</button>
    </div>
    <script>
        // Game constants
        const VIEWPORT_WIDTH = 15;
        const VIEWPORT_HEIGHT = 15;
        const VISIBLE_RADIUS = 5;
        const moveDebounceTime = 200; // Milliseconds

        // Game state
        let TILE_SIZE = 32;
        let player;
        let lastTime = 0;
        let lastMoveTime = 0;

        let dungeon = {
            level: 1,
            width: 50,
            height: 50,
            tiles: [],
            rooms: [],
            monsters: [],
            items: []
        };

        const BASE_ENEMY_MOVE_INTERVAL = 10000; // 10 seconds in milliseconds

        const tileTypes = {
            FLOOR: 0,
            WALL: 1,
            DOOR: 2,
            STAIRS: 3,
            SHOP: 4,
            TRAP: 5,
            LOCKED_DOOR: 6,
            REVEALED_TRAP: 7
        };

        const elements = ['fire', 'water', 'grass', 'lightning', 'radiant', 'darkness', 'ice', 'earth', 'neutral'];

        const cardTypes = {
    ATTACK: { name: 'Attack', emoji: '‚öîÔ∏è', effect: (player, enemy) => enemy.hp -= player.stats.strength, element: 'neutral' },
    DEFEND: { name: 'Defend', emoji: 'üõ°Ô∏è', effect: (player) => player.tempDefense = player.stats.dexterity, element: 'neutral' },
    HEAL: { name: 'Heal', emoji: '‚ù§Ô∏è', effect: (player) => player.stats.hp = Math.min(player.stats.hp + 3, player.stats.maxHp), element: 'neutral' },
    FIRE_ATTACK: { name: 'Fire Attack', emoji: 'üî•', effect: (player, enemy) => enemy.hp -= player.stats.strength + (enemy.element === 'grass' ? 2 : 0), element: 'fire' },
    WATER_ATTACK: { name: 'Water Attack', emoji: 'üíß', effect: (player, enemy) => enemy.hp -= player.stats.strength + (enemy.element === 'fire' ? 2 : 0), element: 'water' },
    GRASS_ATTACK: { name: 'Grass Attack', emoji: 'üçÉ', effect: (player, enemy) => enemy.hp -= player.stats.strength + (enemy.element === 'water' ? 2 : 0), element: 'grass' },
    LIGHTNING_ATTACK: { name: 'Lightning Attack', emoji: '‚ö°', effect: (player, enemy) => enemy.hp -= player.stats.strength + (enemy.element === 'water' ? 2 : 0), element: 'lightning' },
    RADIANT_ATTACK: { name: 'Radiant Attack', emoji: '‚òÄÔ∏è', effect: (player, enemy) => { enemy.hp -= player.stats.strength; player.stats.hp += 1; }, element: 'radiant' },
    DARKNESS_ATTACK: { name: 'Darkness Attack', emoji: 'üåë', effect: (player, enemy) => { enemy.hp -= player.stats.strength; enemy.strength -= 1; }, element: 'darkness' },
    ICE_ATTACK: { name: 'Ice Attack', emoji: '‚ùÑÔ∏è', effect: (player, enemy) => { enemy.hp -= player.stats.strength; enemy.dexterity -= 1; }, element: 'ice' },
    EARTH_ATTACK: { name: 'Earth Attack', emoji: 'üåã', effect: (player, enemy) => enemy.hp -= player.stats.strength + (enemy.element === 'lightning' ? 2 : 0), element: 'earth' },
};

        const weaponCardTypes = {
    LONG_SWORD: { name: 'Long Sword', emoji: 'üó°Ô∏è', effect: (player, enemy) => { enemy.hp -= player.stats.strength * 2; }, element: 'neutral' },
    SHORT_SWORD: { name: 'Short Sword', emoji: 'üî™', effect: (player, enemy) => { enemy.hp -= player.stats.strength * 1.5; player.tempDefense += 2; }, element: 'neutral' },
    AXE: { name: 'Axe', emoji: 'ü™ì', effect: (player, enemy) => { enemy.hp -= player.stats.strength * 2.5; }, element: 'neutral' },
    BOW: { name: 'Bow', emoji: 'üèπ', effect: (player, enemy) => { enemy.hp -= player.stats.dexterity * 2; }, element: 'neutral' },
    MACE: { name: 'Mace', emoji: 'üèè', effect: (player, enemy) => { enemy.hp -= player.stats.strength * 2; enemy.strength -= 1; }, element: 'neutral' },
};

const itemTypes = [
    { name: 'Healing Potion', emoji: 'üß™', hp: 5, consumable: true },
    { name: 'Strength Potion', emoji: 'üí™', strength: 2, duration: 5, consumable: true },
    { name: 'Dexterity Potion', emoji: 'üèÉ', dexterity: 2, duration: 5, consumable: true },
    { name: 'Luck Potion', emoji: 'üçÄ', luck: 2, duration: 5, consumable: true },
    { name: 'Coins', emoji: 'üí∞', value: 0 }
];

        let playerDeck = [];

        const monsterTypes = [
            { name: 'Rat', emoji: 'üêÄ', hp: 5, strength: 2, xp: 5, minLevel: 1 },
            { name: 'Slime', emoji: 'üü¢', hp: 6, strength: 3, xp: 7, minLevel: 1 },
            { name: 'Fairy', emoji: 'üßöüèæ', hp: 7, strength: 4, xp: 15, minLevel: 2 },
            { name: 'Giant Bug', emoji: 'ü™≤', hp: 8, strength: 4, xp: 8, minLevel: 2 },
            { name: 'Goblin', emoji: 'üë∫', hp: 10, strength: 5, xp: 10, minLevel: 3 },
            { name: 'Skeleton', emoji: 'üíÄ', hp: 12, strength: 6, xp: 12, minLevel: 4 },
            { name: 'Ghost', emoji: 'üëª', hp: 15, strength: 7, xp: 15, minLevel: 5 },
            { name: 'Zombie', emoji: 'üßü', hp: 12, strength: 10, xp: 12, minLevel: 6 },
            { name: 'Werewolf', emoji: 'üê∫', hp: 17, strength: 12, xp: 20, minLevel: 7 },
            { name: 'Vampire', emoji: 'üßõ', hp: 20, strength: 15, xp: 23, minLevel: 8 },
            { name: 'Orc', emoji: 'üëπ', hp: 25, strength: 20, xp: 25, minLevel: 9 },
            { name: 'Troll', emoji: 'üßå', hp: 35, strength: 22, xp: 30, minLevel: 10 },
            { name: 'Dragon', emoji: 'üêâ', hp: 40, strength: 10, xp: 35, minLevel: 12 }
        ];

        // const itemTypes = [
        //     { name: 'Long Sword', emoji: 'üó°Ô∏è', strength: 10 },
        //     { name: 'Short Sword', emoji: 'üó°Ô∏è', strength: 8 },
        //     { name: 'Axe', emoji: 'ü™ì', strength: 9 },
        //     { name: 'Boomerang', emoji: 'ü™É', strength: 7 },
        //     { name: 'Bow', emoji: 'üèπ', strength: 4, dexterity: 2 },
        //     { name: 'Leather Armor', emoji: 'üß•', hp: 5 },
        //     { name: 'Mace', emoji: 'üèè', strength: 8 },
        //     { name: 'Dagger', emoji: 'üî™', dexterity: 1, luck: 2 },
        //     { name: 'Healing Potion', emoji: 'üß™', hp: 5, consumable: true },
        //     { name: 'Strength Potion', emoji: 'üí™', strength: 2, duration: 5, consumable: true },
        //     { name: 'Dexterity Potion', emoji: 'üèÉ', dexterity: 2, duration: 5, consumable: true },
        //     { name: 'Luck Potion', emoji: 'üçÄ', luck: 2, duration: 5, consumable: true },
        //     { name: 'Coins', emoji: 'üí∞', value: 0 }
        // ];

        // Canvas setup
        let canvas;
        let ctx;

        function resizeCanvas() {
            if (canvas) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                // Calculate the number of tiles that should fit on the screen
                const tilesX = VIEWPORT_WIDTH;
                const tilesY = VIEWPORT_HEIGHT;
                
                // Calculate TILE_SIZE based on the smaller dimension
                TILE_SIZE = Math.floor(Math.min(
                    canvas.width / tilesX,
                    canvas.height / tilesY
                ));
                
                if (dungeon && dungeon.tiles && player) {
                    drawGame();
                }
            }
        }

        // Add event listener for window resize
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', resizeCanvas);

        function gameLoop(currentTime) {
            update(currentTime);
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        function update(currentTime) {
            if (!lastTime) lastTime = currentTime;
            const deltaTime = currentTime - lastTime;
            
            const moveInterval = Math.max(1000, BASE_ENEMY_MOVE_INTERVAL - (dungeon.level - 1) * 1000);
            
            if (deltaTime >= moveInterval) {
                moveEnemies();
                lastTime = currentTime;
            }
        }

        function moveEnemies() {
            dungeon.monsters.forEach(monster => {
                if (Math.abs(monster.x - player.x) <= 1 && Math.abs(monster.y - player.y) <= 1) {
                    // Monster is adjacent to player, move towards player
                    const dx = Math.sign(player.x - monster.x);
                    const dy = Math.sign(player.y - monster.y);
                    if (isValidMove(monster.x + dx, monster.y + dy)) {
                        monster.x += dx;
                        monster.y += dy;
                    }
                } else {
                    // Monster is not adjacent to player, move randomly
                    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    const validDirections = directions.filter(([dx, dy]) =>
                        isValidMove(monster.x + dx, monster.y + dy)
                    );
                    if (validDirections.length > 0) {
                        const [dx, dy] = validDirections[Math.floor(Math.random() * validDirections.length)];
                        monster.x += dx;
                        monster.y += dy;
                    }
                }
            });
        }

        function isValidMove(x, y) {
            return x >= 0 && x < dungeon.width && y >= 0 && y < dungeon.height && 
                   dungeon.tiles[y][x] !== tileTypes.WALL;
        }

        function drawGame() {
            if (!ctx || !dungeon || !dungeon.tiles || !player) {
                console.log("Game state not fully initialized yet");
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Calculate the number of tiles that can fit on the screen
            const tilesX = Math.floor(canvas.width / TILE_SIZE);
            const tilesY = Math.floor(canvas.height / TILE_SIZE);
            
            // Calculate the start and end of the viewport, centered on the player
            const startX = Math.max(0, Math.floor(player.x - tilesX / 2));
            const startY = Math.max(0, Math.floor(player.y - tilesY / 2));
            const endX = Math.min(dungeon.width, startX + tilesX);
            const endY = Math.min(dungeon.height, startY + tilesY);

            // Calculate offset to center the view and account for partial tiles
            const offsetX = Math.floor((canvas.width - (endX - startX) * TILE_SIZE) / 2);
            const offsetY = Math.floor((canvas.height - (endY - startY) * TILE_SIZE) / 2);

            // Draw tiles
            for (let y = startY; y < endY; y++) {
                if (dungeon.tiles[y]) {
                    for (let x = startX; x < endX; x++) {
                        if (dungeon.tiles[y][x] !== undefined) {
                            const screenX = (x - startX) * TILE_SIZE + offsetX;
                            const screenY = (y - startY) * TILE_SIZE + offsetY;
                            drawTile(dungeon.tiles[y][x], screenX, screenY);
                        }
                    }
                }
            }

            // Draw items
            dungeon.items.forEach(item => {
                if (item.x >= startX && item.x < endX && item.y >= startY && item.y < endY) {
                    const screenX = (item.x - startX) * TILE_SIZE + offsetX;
                    const screenY = (item.y - startY) * TILE_SIZE + offsetY;
                    drawEntity(item, screenX, screenY);
                }
            });

            // Draw monsters
            dungeon.monsters.forEach(monster => {
                if (monster.x >= startX && monster.x < endX && monster.y >= startY && monster.y < endY) {
                    const screenX = (monster.x - startX) * TILE_SIZE + offsetX;
                    const screenY = (monster.y - startY) * TILE_SIZE + offsetY;
                    drawEntity(monster, screenX, screenY);
                }
            });

            // Draw player
            const playerScreenX = (player.x - startX) * TILE_SIZE + offsetX;
            const playerScreenY = (player.y - startY) * TILE_SIZE + offsetY;
            drawEntity(player, playerScreenX, playerScreenY);
        }

        function drawTile(tileType, x, y) {
            let emoji;
            switch (tileType) {
                case tileTypes.FLOOR:
                    emoji = '‚¨ú'; // White large square
                    break;
                case tileTypes.WALL:
                    emoji = 'üß±'; // Brick
                    break;
                case tileTypes.DOOR:
                    emoji = 'üö™'; // Door
                    break;
                case tileTypes.STAIRS:
                    emoji = 'ü™ú'; // Ladder
                    break;
                case tileTypes.SHOP:
                    emoji = 'üè™'; // Convenience store
                    break;
                case tileTypes.TRAP:
                    emoji = '‚¨ú'; // Hidden trap looks like floor
                    break;
                case tileTypes.LOCKED_DOOR:
                    emoji = 'üîí'; // Locked
                    break;
                case tileTypes.REVEALED_TRAP:
                    emoji = '‚ö†Ô∏è'; // Warning sign
                    break;
                default:
                    emoji = '‚ùì'; // Question mark for unknown types
            }
            ctx.font = `${TILE_SIZE}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(emoji, x + TILE_SIZE / 2, y + TILE_SIZE / 2);
        }

        function drawEntity(entity, x, y) {
    ctx.font = `${TILE_SIZE}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(entity.emoji, x + TILE_SIZE / 2, y + TILE_SIZE / 2);
}

        // Input handling
        function movePlayer(dx, dy) {
            const currentTime = Date.now();
            if (currentTime - lastMoveTime < moveDebounceTime) {
                return; // Ignore this move if it's too soon after the last one
            }
            lastMoveTime = currentTime;

            const newX = player.x + dx;
            const newY = player.y + dy;
            if (newX >= 0 && newX < dungeon.width && newY >= 0 && newY < dungeon.height) {
                const tileType = dungeon.tiles[newY][newX];
                if (tileType === tileTypes.FLOOR || tileType === tileTypes.TRAP || tileType === tileTypes.REVEALED_TRAP || tileType === tileTypes.SHOP) {
                    player.x = newX;
                    player.y = newY;
                    if (tileType === tileTypes.TRAP) {
                        handleTrap(newX, newY);
                    } else if (tileType === tileTypes.SHOP) {
                        console.log("Player entered shop tile"); // Debug log
                        openShop();
                    }
                    checkForEncounters();
                    drawGame();  // Redraw the game after moving
                } else if (tileType === tileTypes.LOCKED_DOOR) {
                    const door = dungeon.lockedDoors.find(door => door.x === newX && door.y === newY);
                    if (door && player.inventory.some(item => item.name === 'Key' && item.doorId === door.id)) {
                        unlockDoor(door);
                        player.x = newX;
                        player.y = newY;
                        drawGame();  // Redraw the game after moving
                    } else {
                        showNotification("This door is locked. You need a key to open it.");
                    }
                }
            }
        }

        function initVirtualController() {
            const buttons = [
                { id: 'up-btn', dx: 0, dy: -1 },
                { id: 'down-btn', dx: 0, dy: 1 },
                { id: 'left-btn', dx: -1, dy: 0 },
                { id: 'right-btn', dx: 1, dy: 0 }
            ];

            buttons.forEach(button => {
                const elem = document.getElementById(button.id);
                if (elem) {
                    let touchStarted = false;

                    elem.addEventListener('touchstart', function(e) {
                        e.preventDefault();
                        if (!touchStarted) {
                            touchStarted = true;
                            movePlayer(button.dx, button.dy);
                        }
                    });

                    elem.addEventListener('touchend', function(e) {
                        e.preventDefault();
                        touchStarted = false;
                    });

                    // Keep click event listeners for non-touch devices
                    elem.addEventListener('mousedown', function(e) {
                        e.preventDefault();
                        movePlayer(button.dx, button.dy);
                    });
                }
            });
        }

        function handleTrap(x, y) {
            const trapChance = Math.random();
            if (trapChance > player.stats.luck / 100) {
                const damage = Math.floor(Math.random() * 5) + 1;
                player.stats.hp -= damage;
                showNotification(`You triggered a trap! You take ${damage} damage.`);
                if (player.stats.hp <= 0) {
                    gameOver();
                }
            } else {
                showNotification("Your luck allowed you to avoid the trap!");
            }
            dungeon.tiles[y][x] = tileTypes.REVEALED_TRAP;
        }

        function unlockDoor(door) {
            dungeon.tiles[door.y][door.x] = tileTypes.FLOOR;
            player.inventory = player.inventory.filter(item => !(item.name === 'Key' && item.doorId === door.id));
            showNotification("You unlocked the door!");
        }

        function togglePlayerMenu() {
            const playerMenu = document.getElementById('player-menu');
            playerMenu.style.display = playerMenu.style.display === 'none' ? 'block' : 'none';
            if (playerMenu.style.display === 'block') updatePlayerMenu();
        }

        function initializeGameState() {
            dungeon = {
                level: 1,
                width: 50,
                height: 50,
                tiles: [],
                rooms: [],
                monsters: [],
                items: []
            };
            
            if (!player) {
                player = {};
            }
            
            // Update player properties
            player.x = 0;
            player.y = 0;
            player.race = '';
            player.emoji = 'üë§'; // Default emoji if no race is selected
            player.stats = {
                strength: 5,
                dexterity: 5,
                mana: 5,
                luck: 5,
                hp: 10,
                maxHp: 10,
                xp: 0,
                level: 1
            };
            player.inventory = [];
            player.equippedItems = {
                weapon: null,
                armor: null
            };
            player.coins = 0;
            player.skills = [];
        }

        function generateDungeon() {
            // Cap the dungeon level at 15
            dungeon.level = Math.min(dungeon.level, 15);

            // Scale dungeon size with
            // Scale dungeon size with level
            dungeon.width = 50 + (dungeon.level * 2);
            dungeon.height = 50 + (dungeon.level * 2);

            dungeon.tiles = [];
            dungeon.rooms = [];
            dungeon.monsters = [];
            dungeon.items = [];
            dungeon.traps = [];
            dungeon.lockedDoors = [];
            dungeon.keys = [];

            // Initialize tiles with walls
            for (let y = 0; y < dungeon.height; y++) {
                dungeon.tiles[y] = [];
                for (let x = 0; x < dungeon.width; x++) {
                    dungeon.tiles[y][x] = tileTypes.WALL;
                }
            }

            // Generate rooms
            const numRooms = 5 + Math.floor(dungeon.level * 1.5);
            for (let i = 0; i < numRooms; i++) {
                const room = generateRoom();
                if (placeRoom(room)) {
                    dungeon.rooms.push(room);
                }
            }

            // Connect rooms
            for (let i = 1; i < dungeon.rooms.length; i++) {
                connectRooms(dungeon.rooms[i-1], dungeon.rooms[i]);
            }

            // Place stairs in a random room (not the first one)
            const stairsRoom = dungeon.rooms[1 + Math.floor(Math.random() * (dungeon.rooms.length - 1))];
            const stairsX = stairsRoom.x + Math.floor(Math.random() * stairsRoom.width);
            const stairsY = stairsRoom.y + Math.floor(Math.random() * stairsRoom.height);
            dungeon.tiles[stairsY][stairsX] = tileTypes.STAIRS;

            // Place shop in a random room
            const shopRoom = dungeon.rooms[Math.floor(Math.random() * dungeon.rooms.length)];
            const shopX = shopRoom.x + Math.floor(Math.random() * shopRoom.width);
            const shopY = shopRoom.y + Math.floor(Math.random() * shopRoom.height);
            dungeon.tiles[shopY][shopX] = tileTypes.SHOP;

            // Place traps
            const numTraps = Math.floor(dungeon.level * 1.5);
            for (let i = 0; i < numTraps; i++) {
                placeTrap();
            }

            // Place locked doors and keys
            const numLockedDoors = Math.floor(dungeon.level / 3);
            for (let i = 0; i < numLockedDoors; i++) {
                placeLockedDoorAndKey();
            }

            // Generate monsters and items
            generateMonstersAndItems();

            placePlayerInValidPosition();
        }

        function generateRoom() {
            const minSize = 3;
            const maxSize = 8;
            return {
                x: 0,
                y: 0,
                width: minSize + Math.floor(Math.random() * (maxSize - minSize + 1)),
                height: minSize + Math.floor(Math.random() * (maxSize - minSize + 1))
            };
        }

        function placeRoom(room) {
            const padding = 1;
            let attempts = 50;
            while (attempts > 0) {
                room.x = padding + Math.floor(Math.random() * (dungeon.width - room.width - padding * 2));
                room.y = padding + Math.floor(Math.random() * (dungeon.height - room.height - padding * 2));

                if (isRoomValid(room)) {
                    for (let y = room.y; y < room.y + room.height; y++) {
                        for (let x = room.x; x < room.x + room.width; x++) {
                            dungeon.tiles[y][x] = tileTypes.FLOOR;
                        }
                    }
                    return true;
                }
                attempts--;
            }
            return false;
        }

        function isRoomValid(room) {
            const padding = 1;
            for (let y = room.y - padding; y < room.y + room.height + padding; y++) {
                for (let x = room.x - padding; x < room.x + room.width + padding; x++) {
                    if (y < 0 || y >= dungeon.height || x < 0 || x >= dungeon.width || dungeon.tiles[y][x] === tileTypes.FLOOR) {
                        return false;
                    }
                }
            }
            return true;
        }

        function connectRooms(roomA, roomB) {
            let x = roomA.x + Math.floor(roomA.width / 2);
            let y = roomA.y + Math.floor(roomA.height / 2);
            const targetX = roomB.x + Math.floor(roomB.width / 2);
            const targetY = roomB.y + Math.floor(roomB.height / 2);

            while (x !== targetX || y !== targetY) {
                if (x !== targetX) {
                    x += x < targetX ? 1 : -1;
                } else if (y !== targetY) {
                    y += y < targetY ? 1 : -1;
                }
                dungeon.tiles[y][x] = tileTypes.FLOOR;
            }
        }

        function placeTrap() {
            let x, y;
            do {
                const room = dungeon.rooms[Math.floor(Math.random() * dungeon.rooms.length)];
                x = room.x + Math.floor(Math.random() * room.width);
                y = room.y + Math.floor(Math.random() * room.height);
            } while (dungeon.tiles[y][x] !== tileTypes.FLOOR);
            
            dungeon.tiles[y][x] = tileTypes.TRAP;
            dungeon.traps.push({x, y});
        }

        function placeLockedDoorAndKey() {
            // Place locked door
            let doorX, doorY;
            do {
                const room = dungeon.rooms[Math.floor(Math.random() * dungeon.rooms.length)];
                doorX = room.x + Math.floor(Math.random() * room.width);
                doorY = room.y + Math.floor(Math.random() * room.height);
            } while (dungeon.tiles[doorY][doorX] !== tileTypes.FLOOR);
            
            dungeon.tiles[doorY][doorX] = tileTypes.LOCKED_DOOR;
            const doorId = dungeon.lockedDoors.length;
            dungeon.lockedDoors.push({x: doorX, y: doorY, id: doorId});

            // Place key in a different room
            let keyX, keyY, keyRoom;
            do {
                keyRoom = dungeon.rooms[Math.floor(Math.random() * dungeon.rooms.length)];
                keyX = keyRoom.x + Math.floor(Math.random() * keyRoom.width);
                keyY = keyRoom.y + Math.floor(Math.random() * keyRoom.height);
            } while (dungeon.tiles[keyY][keyX] !== tileTypes.FLOOR || (keyRoom === dungeon.rooms.find(room => doorX >= room.x && doorX < room.x + room.width && doorY >= room.y && doorY < room.y + room.height)));
            
            dungeon.keys.push({x: keyX, y: keyY, id: doorId});
            dungeon.items.push({x: keyX, y: keyY, name: 'Key', emoji: 'üîë', doorId: doorId});
        }

        function placePlayerInValidPosition() {
            // Find a floor tile to place the player
            for (let y = 0; y < dungeon.height; y++) {
                for (let x = 0; x < dungeon.width; x++) {
                    if (dungeon.tiles[y][x] === tileTypes.FLOOR) {
                        player.x = x;
                        player.y = y;
                        return;
                    }
                }
            }
            // If no floor tile found, place player at (0,0) as a fallback
            player.x = 0;
            player.y = 0;
        }

        function generateMonstersAndItems() {
    const numMonsters = dungeon.level + 2;
    const numItems = 3 + Math.floor(Math.random() * 3);

    // Filter monsters based on dungeon level
    const availableMonsters = monsterTypes.filter(monster => monster.minLevel <= dungeon.level);

    for (let i = 0; i < numMonsters; i++) {
        const room = dungeon.rooms[Math.floor(Math.random() * dungeon.rooms.length)];
        
        // Weighted random selection favoring stronger monsters in higher levels
        let totalWeight = 0;
        const weights = availableMonsters.map(monster => {
            const weight = monster.xp * (dungeon.level - monster.minLevel + 1);
            totalWeight += weight;
            return weight;
        });

        let randomWeight = Math.random() * totalWeight;
        let selectedMonsterIndex = 0;
        for (let j = 0; j < weights.length; j++) {
            randomWeight -= weights[j];
            if (randomWeight <= 0) {
                selectedMonsterIndex = j;
                break;
            }
        }

        const monsterTemplate = availableMonsters[selectedMonsterIndex];
        let monsterX, monsterY;
        do {
            monsterX = room.x + Math.floor(Math.random() * room.width);
            monsterY = room.y + Math.floor(Math.random() * room.height);
        } while (dungeon.tiles[monsterY][monsterX] !== tileTypes.FLOOR);

        const monster = {
            x: monsterX,
            y: monsterY,
            ...JSON.parse(JSON.stringify(monsterTemplate))
        };

        // Scale monster stats based on dungeon level
        const levelDifference = dungeon.level - monster.minLevel;
        monster.hp += Math.floor(levelDifference * 1.5);
        monster.strength += Math.floor(levelDifference * 0.5);
        monster.xp += Math.floor(levelDifference * 2);

        // Assign an element to the monster (but don't add elemental emoji)
        monster.element = elements[Math.floor(Math.random() * elements.length)];

        dungeon.monsters.push(monster);
    }

    // Generate items (no changes needed here)
    for (let i = 0; i < numItems; i++) {
        const room = dungeon.rooms[Math.floor(Math.random() * dungeon.rooms.length)];
        let itemX, itemY;
        do {
            itemX = room.x + Math.floor(Math.random() * room.width);
            itemY = room.y + Math.floor(Math.random() * room.height);
        } while (dungeon.tiles[itemY][itemX] !== tileTypes.FLOOR);

        const item = {
            x: itemX,
            y: itemY,
            ...JSON.parse(JSON.stringify(itemTypes[Math.floor(Math.random() * itemTypes.length)]))
        };
        if (item.name === 'Coins') {
            item.value = dungeon.level + Math.floor(Math.random() * 10);
        }
        dungeon.items.push(item);
    }

    // Chance to generate a gem (roughly every 3 levels)
    if (Math.random() < 1/3) {
        const gemRoom = dungeon.rooms[Math.floor(Math.random() * dungeon.rooms.length)];
        let gemX, gemY;
        do {
            gemX = gemRoom.x + Math.floor(Math.random() * gemRoom.width);
            gemY = gemRoom.y + Math.floor(Math.random() * gemRoom.height);
        } while (dungeon.tiles[gemY][gemX] !== tileTypes.FLOOR);

        const gemValue = (dungeon.level * 50) + Math.floor(Math.random() * 50); // Gem value scales with dungeon level
        dungeon.items.push({
            x: gemX,
            y: gemY,
            name: 'Gem',
            emoji: 'üíé',
            value: gemValue
        });
    }
}

function getElementalEmoji(element) {
    switch(element) {
        case 'fire': return 'üî•';
        case 'water': return 'üíß';
        case 'grass': return 'üçÉ';
        case 'lightning': return '‚ö°';
        case 'radiant': return '‚òÄÔ∏è';
        case 'darkness': return 'üåë';
        case 'ice': return '‚ùÑÔ∏è';
        case 'earth': return 'üåã';
        default: return '';
    }
}

function openShop() {
    console.log("openShop function called");
    const shopModal = document.getElementById('shop-modal');
    if (!shopModal) {
        console.error("Shop modal element not found");
        return;
    }
    console.log("Shop modal element found");

    const shopItems = document.getElementById('shop-items');
    const playerInventory = document.getElementById('player-inventory');
    const playerCoinsDiv = document.getElementById('player-coins');

    if (!shopItems || !playerInventory || !playerCoinsDiv) {
        console.error("One or more shop elements not found");
        return;
    }
    console.log("All shop elements found");

    // Clear previous contents
    shopItems.innerHTML = '';
    playerInventory.innerHTML = '';

    // Display shop items
    const shopInventory = [
        { name: 'Healing Potion', price: 10, emoji: 'üß™' },
        { name: 'Strength Potion', price: 15, emoji: 'üí™' },
        { name: 'Dexterity Potion', price: 15, emoji: 'üèÉ' },
        { name: 'Luck Potion', price: 15, emoji: 'üçÄ' }
    ];

    shopInventory.forEach(item => {
        const itemElement = document.createElement('div');
        itemElement.className = 'shop-item';
        itemElement.innerHTML = `
            <span class="item-emoji">${item.emoji}</span>
            <div class="item-details">
                <div class="item-name">${item.name}</div>
                <div class="item-price">${item.price} coins</div>
            </div>
            <button class="buy-btn" data-item="${item.name}" data-price="${item.price}">Buy</button>
        `;
        shopItems.appendChild(itemElement);
    });
    console.log("Shop items populated");

    // Display player inventory (remove duplicates)
    const uniqueInventory = [];
    player.inventory.forEach(item => {
        if (!uniqueInventory.some(i => i.name === item.name)) {
            uniqueInventory.push(item);
        }
    });

    uniqueInventory.forEach(item => {
        const itemElement = document.createElement('div');
        itemElement.className = 'inventory-item';
        itemElement.innerHTML = `
            <span class="item-emoji">${item.emoji}</span>
            <div class="item-details">
                <div class="item-name">${item.name}</div>
                <div class="item-price">Sell for ${item.minLevel || 5} coins</div>
            </div>
            <button class="sell-btn" data-item="${item.name}" data-price="${item.minLevel || 5}">Sell</button>
        `;
        playerInventory.appendChild(itemElement);
    });
    console.log("Player inventory populated");

    // Display player coins
    playerCoinsDiv.textContent = `Your coins: ${player.coins}`;

    // Show the modal
    shopModal.style.display = 'block';
    console.log("Shop modal displayed");

    // Add event listeners
    document.querySelectorAll('.buy-btn').forEach(btn => {
        btn.addEventListener('click', buyItem);
    });

    document.querySelectorAll('.sell-btn').forEach(btn => {
        btn.addEventListener('click', sellItem);
    });

    document.getElementById('close-shop').addEventListener('click', () => {
        shopModal.style.display = 'none';
        console.log("Shop closed");
    });
}

        function buyItem(event) {
            const itemName = event.target.dataset.item;
            const price = parseInt(event.target.dataset.price);

            if (player.coins >= price) {
                player.coins -= price;
                const boughtItem = itemTypes.find(i => i.name === itemName);
                player.inventory.push(JSON.parse(JSON.stringify(boughtItem)));
                showNotification(`You bought a ${itemName}!`);
                openShop(); // Refresh the shop display
            } else {
                showNotification("You don't have enough coins!");
            }
        }

        function sellItem(event) {
    const itemName = event.target.dataset.item;
    const price = parseInt(event.target.dataset.price);
    
    const sellConfirmation = document.getElementById('sell-confirmation');
    const sellMessage = document.getElementById('sell-message');
    const sellYes = document.getElementById('sell-yes');
    const sellNo = document.getElementById('sell-no');

    sellMessage.textContent = `Are you sure you want to sell ${itemName} for ${price} coins?`;
    sellConfirmation.style.display = 'block';

    sellYes.onclick = () => {
        player.coins += price;
        player.inventory = player.inventory.filter(item => item.name !== itemName);
        showNotification(`You sold ${itemName} for ${price} coins.`);
        
        // Chance to get a new card
        if (Math.random() < 0.3) {  // 30% chance
            const newCard = getRandomCard();
            playerDeck.push(newCard);
            showNotification(`You received a new card as a bonus: ${newCard.emoji} ${newCard.name}!`, 5000);
        }
        
        sellConfirmation.style.display = 'none';
        openShop(); // Refresh the shop display
    };

    sellNo.onclick = () => {
        sellConfirmation.style.display = 'none';
    };
}

        function getRandomCard() {
            const cardList = Object.values(cardTypes);
            return cardList[Math.floor(Math.random() * cardList.length)];
        }

        function checkForEncounters() {
    // Check for stairs
    if (dungeon.tiles[player.y][player.x] === tileTypes.STAIRS) {
        dungeon.level++;
        generateDungeon();
        updateHUD();
        showNotification(`You've reached level ${dungeon.level}!`);
    }

    // Check for shop
    if (dungeon.tiles[player.y][player.x] === tileTypes.SHOP) {
        console.log("Player entered shop tile");
        openShop();
    }

    // Check for monsters
    const monsterIndex = dungeon.monsters.findIndex(m => m.x === player.x && m.y === player.y);
    if (monsterIndex !== -1) {
        startCardCombat(dungeon.monsters[monsterIndex]);
    }

    // Check for items
    const itemIndex = dungeon.items.findIndex(i => i.x === player.x && i.y === player.y);
    if (itemIndex !== -1) {
        const item = dungeon.items[itemIndex];
        if (item.name === 'Key') {
            player.inventory.push(item);
            showNotification(`You found a key!`);
        } else if (item.name === 'Coins' || item.name === 'Gem') {
            player.coins += item.value;
            showNotification(`You found ${item.name === 'Gem' ? 'a valuable gem' : 'coins'} worth ${item.value} coins!`);
        } else {
            player.inventory.push(item);
            showNotification(`You found ${item.name}!`);
        }
        dungeon.items.splice(itemIndex, 1);
        updatePlayerMenu();
    }
}

        function startCardCombat(monster) {
    let playerHand = drawHand();
    let playerTempEffects = { tempDefense: 0 };
    const combatUI = document.getElementById('card-combat-ui');
    const monsterInfo = document.getElementById('monster-info');
    const playerInfo = document.getElementById('player-info');
    const cardHand = document.getElementById('card-hand');

    function displayCombatState() {
        monsterInfo.innerHTML = `${monster.emoji} ${monster.name} - HP: ${monster.hp}`;
        playerInfo.innerHTML = `${player.emoji} ${player.race} - HP: ${player.stats.hp}/${player.stats.maxHp}`;
        cardHand.innerHTML = '';
        playerHand.forEach((card, index) => {
            const cardButton = document.createElement('button');
            cardButton.innerHTML = `${card.emoji} ${card.name}`;
            cardButton.onclick = () => playCard(index);
            cardHand.appendChild(cardButton);
        });
    }

    function playCard(index) {
        const playedCard = playerHand[index];
        showNotification(`You played ${playedCard.emoji} ${playedCard.name}`);
        playedCard.effect(player, monster);
        
        // Remove weapon card from inventory if it's a weapon
        if (Object.values(weaponCardTypes).includes(playedCard)) {
            player.inventory = player.inventory.filter(item => item.name !== playedCard.name);
        }
        
        playerHand.splice(index, 1);

        if (monster.hp <= 0) {
            endCombat(true);
            return;
        }

        monsterTurn();
    }

    function monsterTurn() {
        const damage = Math.max(0, monster.strength - playerTempEffects.tempDefense);
        player.stats.hp -= damage;
        showNotification(`${monster.emoji} ${monster.name} attacks for ${damage} damage!`);

        playerTempEffects = { tempDefense: 0 };

        if (player.stats.hp <= 0) {
            endCombat(false);
            return;
        }

        if (playerHand.length < 4) {
            playerHand.push(...drawHand(4 - playerHand.length));
        }

        displayCombatState();
    }

    function endCombat(playerWon) {
        if (playerWon) {
            showNotification(`You defeated the ${monster.name}!`);
            player.stats.xp += monster.xp;
            checkLevelUp();
            // Remove the defeated monster from the dungeon
            dungeon.monsters = dungeon.monsters.filter(m => m !== monster);
        } else {
            showNotification("Game Over! Your adventure has come to an end.");
            gameOver();
        }
        combatUI.style.display = 'none';
        drawGame();
    }

    function decideTurnOrder() {
        const playerRoll = Math.random() + (player.stats.luck / 100);
        const monsterRoll = Math.random();
        return playerRoll >= monsterRoll;
    }

    // Start combat
    combatUI.style.display = 'block';
    if (decideTurnOrder()) {
        showNotification("You get the first move!");
        displayCombatState();
    } else {
        showNotification("The monster strikes first!");
        monsterTurn();
    }
}

        function drawHand(size = 4) {
            let hand = [];
            for (let i = 0; i < size; i++) {
                if (playerDeck.length > 0) {
                    const index = Math.floor(Math.random() * playerDeck.length);
                    hand.push(playerDeck.splice(index, 1)[0]);
                }
            }
            return hand;
        }

        function initializePlayerDeck() {
    playerDeck = [
        cardTypes.ATTACK,
        cardTypes.ATTACK,
        cardTypes.DEFEND,
        cardTypes.DEFEND,
        cardTypes.HEAL,
        cardTypes.FIRE_ATTACK,
        cardTypes.WATER_ATTACK,
        cardTypes.GRASS_ATTACK
    ];

    // Add some random elemental cards
    const elementalCards = [
        cardTypes.LIGHTNING_ATTACK,
        cardTypes.RADIANT_ATTACK,
        cardTypes.DARKNESS_ATTACK,
        cardTypes.ICE_ATTACK,
        cardTypes.EARTH_ATTACK
    ];

    for (let i = 0; i < 2; i++) {
        const randomCard = elementalCards[Math.floor(Math.random() * elementalCards.length)];
        playerDeck.push(randomCard);
    }

    // Add a random weapon card to inventory
    const weaponCards = Object.values(weaponCardTypes);
    const randomWeapon = weaponCards[Math.floor(Math.random() * weaponCards.length)];
    player.inventory.push({...randomWeapon});
}

        function checkLevelUp() {
            const xpThreshold = player.stats.level * 100;
            if (player.stats.xp >= xpThreshold) {
                player.stats.level++;
                player.stats.xp -= xpThreshold;
                player.stats.strength++;
                player.stats.dexterity++;
                player.stats.mana++;
                player.stats.luck++;
                player.stats.maxHp += 5;
                player.stats.hp = player.stats.maxHp;
                showNotification(`Level up! You are now level ${player.stats.level}!`);
                updatePlayerMenu();
            }
        }

        function gameOver() {
            showNotification('Game Over! Your adventure has come to an end.');
            saveProgress();
            showMetaProgressionMenu();
        }

        function saveProgress() {
            let persistentProgress = {
                totalRuns: (parseInt(localStorage.getItem('totalRuns')) || 0) + 1,
                highestLevel: Math.max(dungeon.level, parseInt(localStorage.getItem('highestLevel')) || 0),
                totalCoins: (parseInt(localStorage.getItem('totalCoins')) || 0) + player.coins
            };
            
            for (let key in persistentProgress) {
                localStorage.setItem(key, persistentProgress[key]);
            }
        }

        function showMetaProgressionMenu() {
            document.getElementById('game-container').style.display = 'none';
            document.getElementById('meta-progression-menu').style.display = 'block';
            
            document.getElementById('total-runs').textContent = localStorage.getItem('totalRuns') || 0;
            document.getElementById('highest-level').textContent = localStorage.getItem('highestLevel') || 1;
            document.getElementById('total-coins').textContent = localStorage.getItem('totalCoins') || 0;
        }

        function buyUpgrade(stat) {
            let totalCoins = parseInt(localStorage.getItem('totalCoins')) || 0;
            if (totalCoins >= 10) {
                totalCoins -= 10;
                localStorage.setItem('totalCoins', totalCoins);
                let upgrades = JSON.parse(localStorage.getItem('permanentUpgrades')) || {};
                upgrades[stat] = (upgrades[stat] || 0) + 1;
                localStorage.setItem('permanentUpgrades', JSON.stringify(upgrades));
                showMetaProgressionMenu();
            } else {
                showNotification("Not enough coins!");
            }
        }

        function startNewRun() {
            console.log("Starting new run...");
            document.getElementById('meta-progression-menu').style.display = 'none';
            document.getElementById('start-menu').style.display = 'block';
            document.getElementById('game-container').style.display = 'none';
            
            // Reset player object entirely
            initializeGameState();
            
            // Reset race selection UI
            document.querySelectorAll('.race-btn').forEach(btn => btn.classList.remove('selected'));
            document.getElementById('race-description').textContent = '';
            document.getElementById('ready-btn').style.display = 'none';
        }

        function applyPermanentUpgrades() {
            let upgrades = JSON.parse(localStorage.getItem('permanentUpgrades')) || {};
            for (let stat in upgrades) {
                player.stats[stat] += upgrades[stat];
            }
        }

        function updateHUD() {
            const hudEl = document.getElementById('hud');
            hudEl.innerHTML = `
                LVL:${player.stats.level} | HP:${player.stats.hp}/${player.stats.maxHp} | XP:${player.stats.xp} 
                | üí∞:${player.coins} | ü™ú:${dungeon.level}
            `;
        }

        function updatePlayerMenu() {
            const statsEl = document.getElementById('player-stats');
            statsEl.innerHTML = '';
            for (const [stat, value] of Object.entries(player.stats)) {
                statsEl.innerHTML += `<div>${stat}: ${value}</div>`;
            }

            const inventoryEl = document.getElementById('inventory');
            inventoryEl.innerHTML = '';
            for (const item of player.inventory) {
                const itemEl = document.createElement('div');
                itemEl.className = 'inventory-item';
                itemEl.innerHTML = `
                    <span>${item.emoji} ${item.name}</span>
                    <button class="equip-btn" data-item="${item.name}">Use/Equip</button>
                `;
                inventoryEl.appendChild(itemEl);
            }

            document.querySelectorAll('.equip-btn').forEach(btn => {
                btn.onclick = () => useItem(btn.dataset.item);
            });

            updateHUD();
        }

        function useItem(itemName) {
    const item = player.inventory.find(i => i.name === itemName);
    if (!item) return;

    if (item.consumable) {
        for (const stat in item) {
            if (typeof item[stat] === 'number' && stat !== 'x' && stat !== 'y') {
                player.stats[stat] += item[stat];
            }
        }
        player.inventory = player.inventory.filter(i => i !== item);
        showNotification(`You used the ${item.name}!`);
    } else if (Object.values(weaponCardTypes).some(weapon => weapon.name === item.name)) {
        // It's a weapon card, do nothing (it will be used in combat)
        showNotification(`${item.name} is ready for use in combat.`);
    } else {
        // Handle other equipment (armor, etc.)
        if (player.equippedItems.armor) {
            // Unequip current armor
            player.stats.maxHp -= player.equippedItems.armor.hp;
            player.stats.hp = Math.min(player.stats.hp, player.stats.maxHp);
        }
        player.equippedItems.armor = item;
        player.stats.maxHp += item.hp;
        player.stats.hp += item.hp;

        showNotification(`You equipped the ${item.name}!`);
    }

    updatePlayerMenu();
}

        // Race selection
        const raceButtons = document.querySelectorAll('.race-btn');
        const raceDescription = document.getElementById('race-description');
        const readyButton = document.getElementById('ready-btn');

        raceButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Remove 'selected' class from all buttons
                raceButtons.forEach(btn => btn.classList.remove('selected'));
                // Add 'selected' class to clicked button
                button.classList.add('selected');
                
                player.race = button.dataset.race;
                player.emoji = button.dataset.emoji; // Directly set the emoji here
                console.log(`Race selected: ${player.race}, Emoji: ${player.emoji}`); // Debug log
                updateRaceDescription();
                readyButton.style.display = 'block';
            });
        });

        function updateRaceDescription() {
            const descriptions = {
                human: "+1 to all stats",
                elf: "+3 to dexterity, +1 to mana",
                dwarf: "+3 to strength, +1 to luck",
                halfling: "+2 to dexterity, +2 to luck"
            };
            raceDescription.textContent = descriptions[player.race];
        }

        readyButton.addEventListener('click', () => {
            if (!player.race) {
                showNotification("Please select a race before starting the game.");
                return;
            }

            document.getElementById('start-menu').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            
            // Apply upgrades and bonuses
            applyPermanentUpgrades();
            applyRacialBonuses();
            
            // Generate dungeon and update HUD
            generateDungeon();
            updateHUD();
            
            console.log(`Game starting with race: ${player.race}, emoji: ${player.emoji}`); // Debug log
            
            // Start the game loop
            gameLoop();
            
            // Make sure the canvas is properly sized
            resizeCanvas();
        });

        function applyRacialBonuses() {
            if (!player.race) {
                console.warn("Player race not set. Skipping racial bonuses.");
                return;
            }
            console.log(`Applying racial bonuses for ${player.race}, Current emoji: ${player.emoji}`); // Debug log
            switch (player.race) {
                case 'human':
                    for (const stat in player.stats) {
                        player.stats[stat]++;
                    }
                    player.emoji = 'üë®';
                    break;
                case 'elf':
                    player.stats.dexterity += 3;
                    player.stats.mana++;
                    player.emoji = 'üßù';
                    break;
                case 'dwarf':
                    player.stats.strength += 3;
                    player.stats.luck++;
                    player.emoji = 'üßî';
                    break;
                case 'halfling':
                    player.stats.dexterity += 2;
                    player.stats.luck += 2;
                    player.emoji = 'üßí';
                    break;
            }
            
            // Recalculate max HP based on race
            player.stats.maxHp = player.stats.hp = (player.race === 'elf' || player.race === 'halfling') ?
                player.stats.dexterity + player.stats.luck :
                player.stats.strength + player.stats.luck;
            console.log(`After applying bonuses, emoji: ${player.emoji}`); // Debug log
        }

        // Event listeners for meta-progression menu
        document.getElementById('upgrade-strength').addEventListener('click', () => buyUpgrade('strength'));
        document.getElementById('upgrade-dexterity').addEventListener('click', () => buyUpgrade('dexterity'));
        document.getElementById('upgrade-luck').addEventListener('click', () => buyUpgrade('luck'));
        document.getElementById('start-new-run').addEventListener('click', startNewRun);

        // Menu button
        document.getElementById('menu-btn').addEventListener('click', togglePlayerMenu);

        // Close menu button
        document.getElementById('close-menu').addEventListener('click', togglePlayerMenu);

        function showNotification(message, duration = 3000) {
            const notificationArea = document.getElementById('notification-area');
            const notification = document.createElement('div');
            notification.textContent = message;
            notification.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            notification.style.color = 'white';
            notification.style.padding = '10px';
            notification.style.borderRadius = '5px';
            notification.style.marginBottom = '10px';
            notification.style.transition = 'opacity 0.5s';
            
            notificationArea.appendChild(notification);
            
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => {
                    notificationArea.removeChild(notification);
                }, 500);
            }, duration);
        }

        function handleKeyDown(e) {
            switch (e.key) {
                case 'ArrowUp':
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                    movePlayer(1, 0);
                    break;
                case 'i':
                    togglePlayerMenu();
                    break;
            }
        }

        // Initialize the game
        function initGame() {
            console.log("Initializing game...");
            canvas = document.getElementById('game-canvas');
            if (canvas) {
                ctx = canvas.getContext('2d');
                
                // Initialize game state
                initializeGameState();
                
                // Now it's safe to resize
                resizeCanvas();
                
                // Add event listeners
                window.addEventListener('resize', resizeCanvas);
                document.addEventListener('keydown', handleKeyDown);
                
                // Initialize virtual controller
                initVirtualController();

                document.addEventListener('keydown', function(event) {
                    if (event.key === 's') {
                        console.log("Manual shop trigger");
                        openShop();
                    }
                });

                // Check if the device supports touch, show/hide virtual controller accordingly
                if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                    document.getElementById('virtual-controller').style.display = 'grid';
                } else {
                    document.getElementById('virtual-controller').style.display = 'none';
                }
                
                // Initialize player deck
                initializePlayerDeck();
                
                // Show the meta-progression menu
                showMetaProgressionMenu();
            } else {
                console.error("Canvas element not found!");
            }
        }

        // Start the game
        window.onload = initGame;
    </script>
</body>
</html>